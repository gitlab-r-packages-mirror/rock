% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse_source_by_coderId.R
\name{parse_source_by_coderId}
\alias{parse_source_by_coderId}
\title{Parsing sources separately for each coder}
\usage{
parse_source_by_coderId(input,
  coderId = "\\\\[\\\\[coderId=([a-zA-Z0-9._-]+)\\\\]\\\\]",
  idForOmittedCoderIds = "noCoderId", codeRegexes = c(codes =
  "\\\\[\\\\[([a-zA-Z0-9._>-]+)\\\\]\\\\]"), idRegexes = c(caseId =
  "\\\\[\\\\[cid=([a-zA-Z0-9._-]+)\\\\]\\\\]", stanzaId =
  "\\\\[\\\\[sid=([a-zA-Z0-9._-]+)\\\\]\\\\]", coderId =
  "\\\\[\\\\[coderId=([a-zA-Z0-9._-]+)\\\\]\\\\]"),
  sectionRegexes = c(paragraphs = "---paragraph-break---", secondary =
  "---<[a-zA-Z0-9]?>---"),
  uidRegex = "\\\\[\\\\[uid=([a-zA-Z0-9._-]+)\\\\]\\\\]",
  autoGenerateIds = c("stanzaId"), persistentIds = c("caseId",
  "coderId"), noCodes = "^uid:|^uid=|^dct:|^ci:",
  delimiterRegEx = "^---$", ignoreRegex = "^#",
  ignoreOddDelimiters = FALSE, postponeDeductiveTreeBuilding = FALSE,
  silent = TRUE)
}
\arguments{
\item{input}{For \code{parse_source_by_coderId}, either a character vector
containing the text of the relevant source \emph{or} a path to a file that
contains the source text; for \code{parse_sources_by_coderId}, a path to a
directory that contains the sources to parse.}

\item{coderId}{The regular expression designating the coder identifier.}

\item{idForOmittedCoderIds}{The identifier to use for utterances that have
not been marked by a coder identifier.}

\item{codeRegexes, idRegexes, sectionRegexes}{These are named character vectors with one
or more regular expressions. For \code{codeRegexes}, these specify how to extract the codes
(that were used to code the sources). For \code{idRegexes}, these specify how to extract the
different types of identifiers. For \code{sectionRegexes}, these specify how to extract the
different types of sections. The \code{codeRegexes} and \code{idRegexes} must each contain one
capturing group to capture the codes and identifiers, respectively.}

\item{autoGenerateIds}{The names of the \code{idRegexes} that, if missing, should receive
autogenerated identifiers (which consist of 'autogenerated_' followed by an incrementing
number).}

\item{persistentIds}{The names of the \code{idRegexes} for the identifiers which, once
attached to an utterance, should be attached to all following utterances as well (until
a new identifier with the same name is encountered, after which that identifier will be
attached to all following utterances, etc).}

\item{noCodes}{This regular expression is matched with all codes after they have been
extracted using the \code{codeRegexes} regular expression (i.e. they're matched against the
codes themselves without, for example, the square brackets in the default code regex). Any
codes matching this \code{noCodes} regular expression will be \strong{ignored}, i.e., removed from the
list of codes.}

\item{delimiterRegEx}{The regular expression that is used to extract the YAML fragments.}

\item{ignoreRegex}{The regular expression that is used to delete lines before any other
processing. This can be used to enable adding comments to sources, which are then ignored
during analysis.}

\item{ignoreOddDelimiters}{If an odd number of YAML delimiters is encountered, whether this
should result in an error (\code{FALSE}) or just be silently ignored (\code{TRUE}).}

\item{postponeDeductiveTreeBuilding}{Whether to imediately try to build the deductive
tree(s) based on the information in this file (\code{FALSE}) or whether to skip that. Skipping
this is useful if the full tree information is distributed over multiple files (in which case
you should probably call \code{parse_sources} instead of \code{parse_source}).}

\item{silent}{Whether to provide (\code{FALSE}) or suppress (\code{TRUE}) more detailed progress updates.}
}
\description{
Parsing sources separately for each coder
}
\examples{
### Get path to example source
examplePath <-
  system.file("extdata", package="rock");

### Get a path to one example file
exampleFile <-
  file.path(examplePath, "example-1.rock");

### Parse single example source
parsedExample <- rock::parse_source_by_coderId(exampleFile);

}
